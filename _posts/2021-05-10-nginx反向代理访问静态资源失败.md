---
layout: post
title: nginx反向代理访问静态资源失败
summary: 记录一次nginx反向代理访问静态资源失败原因及相关拓展
featured-img: 154619.jpg
labels: [Nginx, 爬坑记录]
---

### 描述:
&emsp; &emsp; 公司的一个web项目是部署在"内网"A服务器上，访问的入口由"外网"B服务器统一管理， 再通过https请求到B服务器，
B服务器设置相应的请求头，通过nginx反向代理到A服务器访问web服务。

&emsp; &emsp; 因为项目比较小，所以没有采用前后端分离，项目部署过程中也没有报错，登录页面正常访问，但输入账号密码登录跳转时报错，状态码405。

### 分析:  
&emsp; &emsp; web服务启动没问题，所以也是可以通过nginx反向代理的，接口访问正常，但是同样是页面的登录页为什么可以访问，但是登录成功后跳转的页面反而405了呢？ 

&emsp; &emsp; 查阅相关资料后得知，返回405是因为Apache、IIS、Nginx等绝大多数web服务器，都不允许静态文件响应POST请求，而nginx的反向代理则会默认改成POST，这就有问题了。  

### 解决:
```
    既然知道反向代理后会修改成POST请求，那么反向代理之前做个判断不就可以了吗？
    POST请求用proxy_pass，否则GET请求就用rewrite，所以有了以下解决方案的配置
    
    if ($request_method ~ ^(POST)$) {
        proxy_pass http://www.gaogd.com;
        break ;
    }
    rewrite ^/(.*)$   http://www.gaogd.com/$1 permanent;
    
    拓展:
    last
        结束当前的请求处理，用替换后的URI重新匹配location；
        可理解为重写（rewrite）后，发起了一个新请求，进入server模块，匹配location；
        如果重新匹配循环的次数超过10次，nginx会返回500错误；
        返回302 http状态码；
        浏览器地址栏显示重地向后的url
    break
        结束当前的请求处理，使用当前资源，不在执行location里余下的语句；
        返回302 http状态码；
        浏览器地址栏显示重地向后的url
    redirect
        临时跳转，返回302 http状态码；
        浏览器地址栏显示重地向后的url
    permanent
        永久跳转，返回301 http状态码；
        浏览器地址栏显示重定向后的url
    
    再次遇到问题:    
        这个方案并没有实际解决我的问题，这个思路是对的，但前提是rewrite后的地址是可以外网访问的
    前面在背景介绍中有提到，web服务是部署在内网的A服务器的，所以rewrit后显示了A服务器的地址所以访问失败
    
    ----------------------------------------------------------------------------------------------
    
    这次我换了一个解决思路，既然是POST请求静态资源会被405阻拦，那我就获取405，改成200后并设置为GET请求
    最后，这个方案解决了我的问题
    
    error_page 405 =200 @405;
    location @405 {
        proxy_method GET;
        proxy_pass http://xxx;
    }
```
![nginx405](/assets/img/posts/nginx/nginx405.png)

### 遗留的小问题:
登录页面之所以可以访问，是因为用户直接通过https发送的GET请求，再通过nginx反向代理后得到的登录页，转折点就在这，通过反向代理得到的页面之后，再请求就变成了POST了

### 碎碎念:
最开始通过判断去解决的思路是没问题的，但不符合我的场景  
**这里值得思考的是**：如果我的A服务器是外网可以访问的， 那为什么还需要反向代理呢？  
从用户访问的角度考虑，先访问的B服务器，反向代理后会访问到A服务器，这会不会有些多此一举。  
从网络的角度考虑，也显的浪费资源和增加访问响应时间，当然这个感知非常小。  
如果是从安全的角度考虑的话，为了隐藏A服务器所以用了反向代理，只能通过代理访问到，但是rewrite后地址栏就暴露了A服务器了，这也违背了反向代理的初衷。

