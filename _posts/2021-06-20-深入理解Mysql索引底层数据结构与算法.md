---
layout: post
title: 深入理解Mysql索引底层数据结构与算法
summary: 《深入理解Mysql索引底层数据结构与算法》学习笔记
featured-img: 293776.jpg
labels: [mysql, 学习笔记]
---

### 概念
&emsp; &emsp; **索引**是帮助MySQL高效获取数据的**排好序**的**数据结构**

<br>

### 为什么需要索引
&emsp; &emsp; mysql的数据是存储在磁盘当中的，而磁盘是由一圈圈的磁道组成的，所以准确的来说，数据是存储在磁盘当中的磁道中。  
&emsp; &emsp; 写入数据时，是磁头在磁道上按着一圈圈的路径写入数据， 一张表的数据在磁道中并不一定是相邻的，它还存在其他表的数据，
也就是说磁盘中存放的数据会是A表的A1数据，下一条不一定是A表的A2数据，可能是B表的B1数据。
<img class="imgclass" src="/assets/img/posts/mysql/1/img_1.png" style="zoom:50%;"/>


&emsp; &emsp; CPU读取数据都是从内存读取，内存去磁盘中读取数据，select * from t where t.col2 = 89;当select查询数据的时候，会全表扫描数据做比对。  
&emsp; &emsp; CPU读取数据是从内存读取，内存去磁盘中读取数据，开头有说道，一张表的数据在磁道并不是相邻的，也可以理解为数据是分布在不同的磁道上的，
磁头在一个磁道没找到数据时，移动到另一个磁道读取数据就是我们常说的一次磁盘IO，当内存去磁盘读取数据时，至少会发生一次磁盘IO。  

如图，89的数据在第六行，也就意味着查询这条数据至少会发生六次磁盘IO，磁盘IO次数越多，查询的也就越慢了  

**索引的出现就是为了减少磁盘IO的次数，从而提升查询的速度**  
&emsp; &emsp; Mysql用的索引数据结构是B+树，后面会说明为什么是B+树，通过多个不同的数据结构演示过来  
&emsp; &emsp; 这里举例子，假设col2字段建立索引，用的是二叉树结构（如图），二叉树的每个节点存放key，value，
key就是索引字段的值，value就是索引所在行的磁盘地址，当我们查询89这条数据是，只需要经过两次磁盘IO即可定位到数据的磁盘地址，再通过地址找到具体的数据。
<img class="imgclass" src="/assets/img/posts/mysql/1/img.png" style="zoom:50%;"/>


```hgignore
总结：  
1、MySQL的数据都是以文件的形势存储在磁盘上的。  
2、磁盘是由一圈一圈的磁道组成。  
3、读取数据时，磁头移动到不同的磁道，磁盘旋转，通过这样的方式读到数据。  
4、CPU读取数据都是从内存读取，内存去磁盘中读取数据。  
5、当磁头移动到另一个磁道读取数据就是我们常说的一次I/O操作，MySQL数据是分布在不同的磁道上的，每次读取数据都要把所有的磁道读取一遍。 那我们进行I/O操作的次数就很多了，查询效率就很低。  
6、索引就是把索引字段数据的地址保存起来，来帮助MySQL直接定位到哪个磁道哪个扇区，这样就减少了I/O的操作次数了，自然查询效率就提高了。  
```

<br>

### 索引数据结构红黑树，B树，B+树，Hash详解
#### 1.红黑树  
&emsp; &emsp; 前面有举例二叉树的数据结构索引，但它并不适用于递增or递减的数据， 二叉树的数据结构是，小于节点的数值，放在左边，
大于节点的数值，放在右边，当数据是递增or递减时，二叉树最后的结构会跟链表一样，例如图中的col1，二叉树最后的结构会变成  
<img class="imgclass" src="/assets/img/posts/mysql/1/二叉树_递增.png" style="zoom:50%;"/>


&emsp; &emsp; 所以有了红黑树的索引，红黑树可以理解为是平衡二叉树，例如，插入1时做根节点，插入2时与根节点判断一下，2大于1吗？大于放右边
插入3时，判断3大于1吗？大于放右边，再跟2判断，3大于2吗？大于，这时候就会做一个平衡，让2变成根节点，1放在2的左边，3放在2的右边  
<img class="imgclass" src="/assets/img/posts/mysql/1/红黑树.png"/>

#### 2.B树  
&emsp; &emsp; 当数据量持续增长时，树的节点高度就会变得原来越高，例如高度有20，当查询的数值在最下面的节点，查询依旧会慢，
但如果我没限制树的高度呢？无论数据量有多大，都让树的高度保持在3，所以衍生了B树  
&emsp; &emsp; 红黑树是一个根节点一直往下，B树则是往下到一定的高度，则纵向增加一个根节点，再往下增，这个纵向增加的多个节点形成的一个页，也叫做**文件页**
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609141800324.png"/>

```hgignore
data是k-v结构,
key就是索引字段的值，value根据不同的数据库表引擎（MyISAM引擎和InnoDB引擎）存放的不同，
MyISAM引擎存放的是地址值，拿到地址值，再通过地址值找到具体的数据
InnoDB引擎存放的是除了索引剩余的字段数据都放在了一块，通过索引可以直接定位到具体的数据

数据库表引擎后面会再细讲
```

#### 3.B+树（B树的变种）  
&emsp; &emsp; 因为B树的结构是索引+数据，mysql为了在文件页存储更多的索引，所以衍生了B+树，
并对B+树结构还做了优化，正常的B+树结构是→的单箭头，但mysql的B+树是双箭头
<img class="imgclass" src="/assets/img/posts/mysql/1/B+tree.png"/>
&emsp; &emsp; 非叶子节点只存放冗余索引，这些冗余索引是叶子节点的第一个索引元素
例如图中的叶子节点的第一个索引15，20，49，则是非叶子节点的索引，因为重复，所以叫冗余索引
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609143207928.png"/>


**mysql的文件页**  
&emsp; &emsp; 查看mysql文件页大小（16K）：SHOW GLOBAL STATUS like 'Innodb_page_size’;    

**为什么mysql页文件默认16K？**  
&emsp; &emsp; 假设我们一行数据大小为1K，那么一页就能存16条数据，也就是一个叶子节点能存16条数据；再看非叶子节点，假设主键ID为bigint类型，那么长度为8B，
指针大小（磁盘文件地址）在Innodb源码中为6B，一共就是14B，那么一页里就可以存储16K/14=1170个(主键+指针)  
&emsp; &emsp; 那么一颗高度为2的B+树能存储的数据为：1170x16=18720条，一颗高度为3的B+树能存储的数据为：1170x1170x16=21902400（千万级条），
所以默认的16k就够用了，如果数据量过亿一般就会选择分库分表了

```hgignore
看，当用了索引，B+树的高度是3时，查询千万级别的数据只需要经过3次磁盘IO就能查询， 但如果没有加索引，而数据又在靠后时，
全表扫描，一行一行的从磁盘读到内存比对，自然就慢了，如果数据在第一千万条，则会经过一千万次磁盘IO
```

**为什么mysql索引选择了B+树，而不是B树**  
&emsp; &emsp; 因为B+树有叶子节点和非叶子节点的概念，非叶子节点存放的是冗余索引，叶子节点存放着索引和数据，并且数据之间有着相邻的索引，
而B树的每个节点存放的都是索引加数据，且没有相邻索引，数据占用的空间比索引大得多，是在同一个文件页内，B+树比B树可存放更多的节点，
也就意味着B+树的高度会比B树低，树的高度越低，磁盘IO次数越少，查询就越快了。  
&emsp; &emsp; 还有一点就是相邻索引，当范围查询时，B+树可以很快的通过相邻索引获取到下一个索引，B树则需要重新从根节点从上往下找

#### 4.Hash索引
&emsp; &emsp; 将索引下的字段进行hash运算存放起来，key=字段 value=数据所在地址，hash碰撞则以链表的形式存放。  
&emsp; &emsp; 查询时select * from t where t.clo1 = 'Alice'
会将Alice 进行hash运行，假设得到2，发现2有多个时，会比对一次key（Alice）拿到地址值  
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609175050717.png" style="zoom:50%;"/>

```hgignore
特点：  
1.对索引的key进行一次hash计算就可以定位出数据存储的位置
2.通过一次磁盘IO就可以找到数据
3.很多时候Hash索引要比B+ 树索引更高效
4.仅能满足 “=”，“IN”，不支持范围查询
5.hash冲突问题

弊端：
因为不支持范围查询，例如> <，当索引没匹配上时，最终还是会全表扫描，这个索引就没意义了，所以在实际运用中还是以B+树的索引为主
```

<br>

### 聚集索引（聚簇索引），稀疏索引（非聚集索引）到底是什么
MyISAM引擎和InnoDB引擎 形容的是数据库表  

MyISAM引擎的表在磁盘的文件格式  
MyISAM索引文件和数据文件是分离的，所以也称之为**非聚集索引**  
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609163554380.png"/>

MyISAM引擎通过索引查询数据过程，假设查询的是col1=30
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609163446558.png"/>

<br>

InnoDB引擎的表在磁盘的文件格式
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609164848170.png"/>  
表数据文件本身就是按B+Tree组织的一个索引结构文件（ibd文件）  
ibd是把所有对应的数据都放里面了，数据的格式也是B+树结构  
ibd是把除了索引剩余的字段数据都放在了一块  
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609165340906.png"/>
叶节点包含了完整的数据记录称之为**聚集索引**

**mysql最开始用的是MyISAM引擎，后来为什么改成了InnoDB引擎**  
&emsp; &emsp; 因为聚集索引是直接取的数据（InnoDB引擎），非聚集索引取的是数据地址（MyISAM引擎），
再通过地址取MYD文件查找，多了一次磁盘IO，所以聚集索引比非聚集索引查找速度快

<br>

### 为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键
**1.为什么建议InnoDB表必须建主键**  
&emsp; &emsp; 因为表数据文件（ibd）本身就是按B+树组织的一个索引结构文件，所以建立主键时，就会在ibd里面有个主键索引组织的B+树结构文件，
如果不建立主键，InnoDB会从表的第一列开始逐列查找一列数据不重复的列（字段）作为索引组织的B+树结构文件，
如果每一列都有重复，则会建一个隐藏列生成唯一id（rootId ）作为索引组织的B+树结构文。  
&emsp; &emsp; 如果不建立主键，InnoDB就会帮我们去找唯一索引，这就增加了mysql的工作量，本身一张表增加一个主键也是正常的


```hgignore
拓展：
聚集索引只有一个，也就是主键索引组织的B+树结构文件
如果没有主键索引，InnoDB就会帮我们去找唯一索引（不重复的列or隐藏列rootId ）

还有一种索引是辅助索引，也就是我们自己创建的索引
这个索引的结构大部分一样，不同的是叶子节点放的不是完整数据，而是聚集索引，如图

这种索引也可以理解为非聚集索引，因为它找到聚集的索引后还需要去到聚集索引的B+树里去找
```

<img class="imgclass" id="" src="/assets/img/posts/mysql/1/image-20210609190319425.png"/>

```hgignore
思考：
为什么非主键索引结构叶子节点存储的是主键值（聚集索引）？
一致性和节省存储空间
```

**2.为什么推荐使用整型的自增主键**  
**2.1为什么推荐整型**  
&emsp; &emsp; 因为整型数字类型的主键更方便于mysql比对查找，增加性能，如果是字符串，则会通过ASCII转换成数字再比对，
而且字符串是会把每个字符转换比对，字符越长比对越多，并且字符串占用的空间也比较大，占用空间越大在一个文件页的冗余索引数量就越是少，
树的高度就越高，磁盘IO次数越多，查询就更慢了
&emsp; &emsp; 所以字符串作为主键，相对于整型主键，查询的效率有比对的效率慢和磁盘IO次数多查询慢

**2.2为什么推荐用自增**  
&emsp; &emsp; 如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，
就会自动开辟一个新的页。如下图所示：  
&emsp; &emsp; 这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，
也不会增加很多开销在维护索引上。
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609183616990.png"/>  


&emsp; &emsp; 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。  
&emsp; &emsp; 此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，
这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。  
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609183653555.png"/>

**因此，只要可以，请尽量在InnoDB上采用自增字段做主键。**

<br>

### 联合索引底层数据结构又是怎样的
索引是排好序的数据结构，联合索引也会排序，但它是根据**索引最左前缀原理**排序  
如图：  
会先排序name字段，如果name不相同，则就按name排序  
如果name相同则会根据age排序，依次往下
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609191822333.png"/>

**mysql查询时会根据索引最左前缀原理判断是否走索引**  
查询时，第一条会走索引，因为条件是name和age  
第二条不会走索引，因为条件只有age，positIOn，没有最左边的name  
第三条同理，不会走索引  
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609192411280.png"/>

**思考：**  
最左前缀原理查询时判断是否走索引为什么一定要先有name，再有age，再有positIOn  
因为联合索引排序的时候就是根据最左前缀原理排序的  
例如第二条查询，查询条件没有name，只有age，positIOn  
那从图中只看age的话，这不是排好序的，并不符合索引的排好序规则  
<img class="imgclass" src="/assets/img/posts/mysql/1/image-20210609193327571.png"/>

**再思考，索引为什么一定要排好序？**  
假设所有不是从左到右排好序的，是随机的，当我们查询age=30的时候，第一个查到了，但假设不是排好序，
我们并不知道后面还有没30的值，则会全表扫描，那么索引就没有意义了，所以索引必须是遵循排好序的原则

**这里再衍生一个思考**  
跟索引最左前缀原理无关，就是普通索引（辅助索引）中存在重复的值，底层会怎么查询，索引肯定是排好序的，
相同的值排在下一个，但辅助索引对应的主键索引（聚集索引）肯定是唯一的，例如

辅助索引 30  30  31  
聚集索引 1   2   3

我们要查询x=30，当拿到第一个30后，第二个30就不管了吗？
我理解的是，在查找30这个索引时，拿到第一个30会继续往下一个找，如果找到的数字是大于30的就不再往下了，如果还找到了30则再往下判断，最终拿到两个30索引对应的的数据



<script src="{{ '/assets/js/jquery.min.js' | relative_url }}"></script>
<script src="{{ '/assets/js/viewer.min.js' | relative_url }}"></script>
<link rel="stylesheet" href="{{ '/assets/css/viewer.min.css' | prepend: site.baseurl }}">
<script>
$('.imgclass').viewer();
</script>